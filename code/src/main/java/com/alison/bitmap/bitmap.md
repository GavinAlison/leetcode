## BitMap
BitMap从字面的意思，很多人认为是位图，其实准确的来说，翻译成基于位的映射。    
所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。

## bitmap应用
1.  可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下。
2.  去重数据而达到压缩数据
3.  还可以用于爬虫系统中url去重、解决全组合问题。

## 算法流程
[https://blog.csdn.net/gongpulin/article/details/81137548](https://blog.csdn.net/gongpulin/article/details/81137548)
要把一个整数N映射到Bit-Map中去，首先要确定把这个N Mapping到哪一个数组元素中去，即确定映射元素的index。
我们用int类型的数组作为map的元素，这样我们就知道了一个元素能够表示的数字个数(这里是32)。
于是N/32就可以知道我们需要映射的key了。所以余下来的那个N%32就是要映射到的位数。

-   1.求十进制数对应在数组a中的下标：    
先由十进制数n转换为与32的余可转化为对应在数组a中的下标。    
如十进制数0-31，都应该对应在a[0]中，比如n=24,那么 n/32=0，则24对应在数组a中的下标为0。
又比如n=60,那么n/32=1，则60对应在数组a中的下标为1，同理可以计算0-N在数组a中的下标。

    ```i = N>>K    % 结果就是N/(2^K)```

    Note: map的范围是[0, 原数组最大的数对应的2的整次方数-1]。

-   2.求十进制数对应数组元素a[i]在0-31中的位m：    
十进制数0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。

    `m = n & ((1 << K) - 1)      %结果就是n%(2^K)`

-   3.利用移位0-31使得对应第m个bit位为1

    `如a[i]的第m位置1：a[i] = a[i] | (1<<m)`

    如：将当前4对应的bit位置1的话，只需要1左移4位与B[0] | 即可。

## 相关问题
1.  使用位图法判断整形数组是否存在重复
2.  在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数
3.  已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。


## 语言实现
-   java 实现： https://my.oschina.net/crxy/blog/408138
bitMap 讲解： https://my.oschina.net/crxy/blog/408138
-   Python 实现： https://blog.csdn.net/gongpulin/article/details/81137548
-   C/C++ 实现： https://blog.csdn.net/hguisu/article/details/7880288
